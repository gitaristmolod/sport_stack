<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sport Stack</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            touch-action: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #topBar {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            font-weight: bold;
            backdrop-filter: blur(10px);
        }

        #score {
            font-size: 24px;
        }

        #nextBall {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }

        #canvas {
            flex: 1;
            display: block;
            background: linear-gradient(to bottom, #2c3e50 0%, #34495e 100%);
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            color: white;
            display: none;
            z-index: 1000;
        }

        #gameOver h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #e74c3c;
        }

        #gameOver p {
            font-size: 24px;
            margin-bottom: 30px;
        }

        #restartBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 15px 40px;
            font-size: 20px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
        }

        #restartBtn:active {
            transform: scale(0.95);
        }

        .emoji {
            font-size: 32px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="topBar">
            <div id="score">–°–ß–Å–¢: <span id="scoreValue">0</span></div>
            <div id="nextBall">
                <span>–î–ê–õ–¨–®–ï:</span>
                <span class="emoji" id="nextBallEmoji">üèì</span>
            </div>
        </div>
        <canvas id="canvas"></canvas>
        <div id="gameOver">
            <h1>GAME OVER!</h1>
            <p>–§–∏–Ω–∞–ª—å–Ω—ã–π —Å—á—ë—Ç: <span id="finalScore">0</span></p>
            <button id="restartBtn">üîÑ –ù–û–í–ê–Ø –ò–ì–†–ê</button>
        </div>
    </div>

    <script>
        const tg = window.Telegram.WebApp;
        tg.expand();
        tg.disableVerticalSwipes();

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('scoreValue');
        const nextBallEmoji = document.getElementById('nextBallEmoji');
        const gameOverDiv = document.getElementById('gameOver');
        const finalScoreElement = document.getElementById('finalScore');
        const restartBtn = document.getElementById('restartBtn');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight - 60;

        const BALL_TYPES = {
            'ping_pong': { 
                radius: 15, color: '#FFFFFF', emoji: 'üèì', next: 'tennis', points: 15,
                mass: 0.3, bounce: 0.9, friction: 0.98
            },
            'tennis': { 
                radius: 20, color: '#ADFF2F', emoji: 'üéæ', next: 'baseball', points: 30,
                mass: 0.8, bounce: 0.85, friction: 0.97
            },
            'baseball': { 
                radius: 25, color: '#FFFFFF', emoji: '‚öæ', next: 'volleyball', points: 50,
                mass: 2.0, bounce: 0.6, friction: 0.95
            },
            'volleyball': { 
                radius: 35, color: '#FFFFFF', emoji: 'üèê', next: 'football', points: 80,
                mass: 3.5, bounce: 0.8, friction: 0.96
            },
            'football': { 
                radius: 40, color: '#FFFFFF', emoji: '‚öΩ', next: 'basketball', points: 120,
                mass: 5.0, bounce: 0.75, friction: 0.94
            },
            'basketball': { 
                radius: 50, color: '#FF8C00', emoji: 'üèÄ', next: 'bowling', points: 170,
                mass: 7.0, bounce: 0.82, friction: 0.95
            },
            'bowling': { 
                radius: 60, color: '#000000', emoji: 'üé≥', next: 'medicine', points: 230,
                mass: 80.0, bounce: 0.2, friction: 0.85
            },
            'medicine': { 
                radius: 75, color: '#8B4513', emoji: '‚öñÔ∏è', next: 'exercise', points: 300,
                mass: 120.0, bounce: 0.3, friction: 0.88
            },
            'exercise': { 
                radius: 95, color: '#4682B4', emoji: 'üí™', next: null, points: 400,
                mass: 150.0, bounce: 0.5, friction: 0.90
            }
        };

        class Ball {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.radius = BALL_TYPES[type].radius;
                this.color = BALL_TYPES[type].color;
                this.mass = BALL_TYPES[type].mass;
                this.bounce = BALL_TYPES[type].bounce;
                this.friction = BALL_TYPES[type].friction;
                this.vx = 0;
                this.vy = 0;
                this.merged = false;
                this.age = 0;
            }

            draw() {
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 5;

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 3;
                ctx.stroke();

                ctx.shadowColor = 'transparent';
                ctx.beginPath();
                ctx.arc(this.x - this.radius/3, this.y - this.radius/3, this.radius/4, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fill();

                ctx.restore();
            }
        }

        class Game {
            constructor() {
                this.balls = [];
                this.score = 0;
                this.gameOver = false;
                this.nextBallType = this.randomBallType();
                this.dropX = canvas.width / 2;
                this.containerY = 100;
                this.containerLeft = 40;
                this.containerRight = canvas.width - 40;
                this.containerBottom = canvas.height - 30;
                this.isDropping = false;
            }

            randomBallType() {
                const types = ['ping_pong', 'tennis', 'baseball', 'volleyball'];
                return types[Math.floor(Math.random() * types.length)];
            }

            dropBall() {
                if (this.gameOver || this.isDropping) return;
                this.isDropping = true;
                const ball = new Ball(this.dropX, this.containerY - 30, this.nextBallType);
                this.balls.push(ball);
                this.nextBallType = this.randomBallType();
                nextBallEmoji.textContent = BALL_TYPES[this.nextBallType].emoji;
                
                setTimeout(() => {
                    this.isDropping = false;
                }, 500);
            }

            updatePhysics() {
                const gravity = 0.35;

                for (let ball of this.balls) {
                    if (ball.merged) continue;

                    ball.age++;
                    
                    // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è —Å —É—á–µ—Ç–æ–º –º–∞—Å—Å—ã (—Ç—è–∂–µ–ª—ã–µ –ø–∞–¥–∞—é—Ç –±—ã—Å—Ç—Ä–µ–µ –æ—â—É—Ç–∏–º–æ)
                    ball.vy += gravity * (1 + ball.mass * 0.01);
                    
                    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏
                    ball.x += ball.vx;
                    ball.y += ball.vy;

                    // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å –ª–µ–≤–æ–π —Å—Ç–µ–Ω–∫–æ–π
                    if (ball.x - ball.radius < this.containerLeft) {
                        ball.x = this.containerLeft + ball.radius;
                        ball.vx *= -ball.bounce;
                    }
                    
                    // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å –ø—Ä–∞–≤–æ–π —Å—Ç–µ–Ω–∫–æ–π
                    if (ball.x + ball.radius > this.containerRight) {
                        ball.x = this.containerRight - ball.radius;
                        ball.vx *= -ball.bounce;
                    }
                    
                    // –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å –¥–Ω–æ–º
                    if (ball.y + ball.radius > this.containerBottom) {
                        ball.y = this.containerBottom - ball.radius;
                        ball.vy *= -ball.bounce;
                        ball.vx *= ball.friction;
                        
                        // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ—á–µ–Ω—å –º–µ–¥–ª–µ–Ω–Ω—ã–µ –¥–≤–∏–∂–µ–Ω–∏—è
                        if (Math.abs(ball.vy) < 0.5) ball.vy = 0;
                        if (Math.abs(ball.vx) < 0.3) ball.vx = 0;
                    }

                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ game over
                    if (ball.y - ball.radius < this.containerY && ball.age > 60 && Math.abs(ball.vy) < 1) {
                        this.endGame();
                    }
                }

                this.checkCollisions();
            }

            checkCollisions() {
                const mergedPairs = [];

                for (let i = 0; i < this.balls.length; i++) {
                    const b1 = this.balls[i];
                    if (b1.merged) continue;

                    for (let j = i + 1; j < this.balls.length; j++) {
                        const b2 = this.balls[j];
                        if (b2.merged) continue;

                        const dx = b2.x - b1.x;
                        const dy = b2.y - b1.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const minDist = b1.radius + b2.radius;

                        if (dist < minDist && dist > 0) {
                            // –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –≤–µ–∫—Ç–æ—Ä —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è
                            const nx = dx / dist;
                            const ny = dy / dist;
                            
                            // –†–∞–∑–¥–µ–ª—è–µ–º –º—è—á–∏ —á—Ç–æ–±—ã –æ–Ω–∏ –Ω–µ –ø–µ—Ä–µ—Å–µ–∫–∞–ª–∏—Å—å
                            const overlap = minDist - dist;
                            const totalMass = b1.mass + b2.mass;
                            const ratio1 = b2.mass / totalMass;
                            const ratio2 = b1.mass / totalMass;
                            
                            b1.x -= nx * overlap * ratio1;
                            b1.y -= ny * overlap * ratio1;
                            b2.x += nx * overlap * ratio2;
                            b2.y += ny * overlap * ratio2;

                            // –û—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
                            const dvx = b2.vx - b1.vx;
                            const dvy = b2.vy - b1.vy;
                            const dvn = dvx * nx + dvy * ny;

                            // –ú—è—á–∏ –æ—Ç—Ç–∞–ª–∫–∏–≤–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –¥–≤–∏–∂—É—Ç—Å—è –¥—Ä—É–≥ –∫ –¥—Ä—É–≥—É
                            if (dvn < 0) {
                                // –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —Ä–µ—Å—Ç–∏—Ç—É—Ü–∏–∏ (—É–ø—Ä—É–≥–æ—Å—Ç—å —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è)
                                const restitution = Math.min(b1.bounce, b2.bounce);
                                
                                // –ò–º–ø—É–ª—å—Å —Å —É—á–µ—Ç–æ–º –º–∞—Å—Å—ã
                                const impulse = (-(1 + restitution) * dvn) / (1/b1.mass + 1/b2.mass);
                                
                                // –ü—Ä–∏–º–µ–Ω—è–µ–º –∏–º–ø—É–ª—å—Å
                                b1.vx -= (impulse / b1.mass) * nx;
                                b1.vy -= (impulse / b1.mass) * ny;
                                b2.vx += (impulse / b2.mass) * nx;
                                b2.vy += (impulse / b2.mass) * ny;
                            }

                            // –°–ª–∏—è–Ω–∏–µ –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö –º—è—á–µ–π
                            if (b1.type === b2.type && b1.age > 30 && b2.age > 30) {
                                mergedPairs.push([i, j]);
                            }
                        }
                    }
                }

                // –í—ã–ø–æ–ª–Ω—è–µ–º —Å–ª–∏—è–Ω–∏—è
                for (let [i, j] of mergedPairs) {
                    const b1 = this.balls[i];
                    const b2 = this.balls[j];
                    const nextType = BALL_TYPES[b1.type].next;

                    if (nextType) {
                        const totalMass = b1.mass + b2.mass;
                        const newBall = new Ball(
                            (b1.x * b1.mass + b2.x * b2.mass) / totalMass,
                            (b1.y * b1.mass + b2.y * b2.mass) / totalMass,
                            nextType
                        );
                        
                        // –ü–µ—Ä–µ–¥–∞–µ–º –∏–º–ø—É–ª—å—Å –Ω–æ–≤–æ–º—É –º—è—á—É
                        newBall.vx = (b1.vx * b1.mass + b2.vx * b2.mass) / totalMass * 0.5;
                        newBall.vy = (b1.vy * b1.mass + b2.vy * b2.mass) / totalMass * 0.5;
                        
                        this.balls.push(newBall);
                        this.score += BALL_TYPES[nextType].points;
                        scoreElement.textContent = this.score;
                        
                        if (tg.HapticFeedback) {
                            tg.HapticFeedback.impactOccurred('medium');
                        }
                    }

                    b1.merged = true;
                    b2.merged = true;
                }

                this.balls = this.balls.filter(b => !b.merged);
            }

            render() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = 'rgba(236, 240, 241, 0.2)';
                ctx.fillRect(this.containerLeft - 10, this.containerY, 10, this.containerBottom - this.containerY);
                ctx.fillRect(this.containerRight, this.containerY, 10, this.containerBottom - this.containerY);
                ctx.fillRect(this.containerLeft - 10, this.containerBottom, this.containerRight - this.containerLeft + 20, 10);

                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.moveTo(this.containerLeft, this.containerY);
                ctx.lineTo(this.containerRight, this.containerY);
                ctx.stroke();
                ctx.setLineDash([]);

                for (let ball of this.balls) {
                    ball.draw();
                }

                const nextRadius = BALL_TYPES[this.nextBallType].radius;
                const nextColor = BALL_TYPES[this.nextBallType].color;

                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.dropX, 60);
                ctx.lineTo(this.dropX, this.containerY);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.beginPath();
                ctx.arc(this.dropX, this.containerY - 30, nextRadius, 0, Math.PI * 2);
                ctx.strokeStyle = nextColor;
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            endGame() {
                if (this.gameOver) return;
                this.gameOver = true;
                finalScoreElement.textContent = this.score;
                gameOverDiv.style.display = 'block';
                
                if (tg.HapticFeedback) {
                    tg.HapticFeedback.notificationOccurred('error');
                }
                
                tg.MainButton.setText('–ù–û–í–ê–Ø –ò–ì–†–ê');
                tg.MainButton.show();
                tg.MainButton.onClick(() => {
                    location.reload();
                });
            }
        }

        const game = new Game();

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            game.dropX = touch.clientX - rect.left;
            game.dropX = Math.max(game.containerLeft + 30, Math.min(game.containerRight - 30, game.dropX));
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            game.dropX = touch.clientX - rect.left;
            game.dropX = Math.max(game.containerLeft + 30, Math.min(game.containerRight - 30, game.dropX));
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            game.dropBall();
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            game.dropX = e.clientX - rect.left;
            game.dropX = Math.max(game.containerLeft + 30, Math.min(game.containerRight - 30, game.dropX));
            game.dropBall();
        });

        restartBtn.addEventListener('click', () => {
            location.reload();
        });

        function gameLoop() {
            if (!game.gameOver) {
                game.updatePhysics();
            }
            game.render();
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
        tg.ready();
    </script>
</body>
</html>
